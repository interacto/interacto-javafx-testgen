/*
 * Interacto
 * Copyright (C) 2020 Arnaud Blouin
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package io.github.interacto.jfx.testgen;

import io.github.interacto.command.CommandImpl;
import io.github.interacto.jfx.test.CommandTest;
import io.github.interacto.jfx.test.UndoableCmdTest;
import io.github.interacto.undo.Undoable;
import java.lang.annotation.Annotation;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Tag;
import spoon.reflect.code.CtBlock;
import spoon.reflect.code.CtComment;
import spoon.reflect.declaration.CtAnnotation;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.declaration.CtField;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.declaration.CtTypeParameter;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtTypeParameterReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.template.Substitution;

public class CmdTestGenerator {
	private final CtClass<?> cmd;

	private CtTypeReference<?> cmdTypeRef;
	private Factory factory;
	private CtClass<?> testClass;
	boolean isUndoable;
	private List<CtField<?>> fields;

	public CmdTestGenerator(final CtClass<?> cmd) {
		super();
		this.cmd = cmd;
	}


	public void generate() {
		factory = cmd.getFactory();
		cmdTypeRef = factory.createCtTypeReference(CommandImpl.class);
		testClass = factory.createClass(cmd.getPackage(), cmd.getSimpleName() + "Test");
		isUndoable = cmd.isSubtypeOf(factory.createCtTypeReference(Undoable.class));

		final var annotTag = factory.createAnnotation(factory.createCtTypeReference(Tag.class));
		annotTag.addValue("value", "command");
		testClass.addAnnotation(annotTag);

		testClass.addComment(factory.createComment("Test class for the command " + cmd.getSimpleName() +
				". Generated by Interacto test-gen.", CtComment.CommentType.JAVADOC));

		addSuperTestClass();

		Substitution.insertAllMethods(testClass, new CmdTestClassTemplate());
		final CtAnnotation<Annotation> overrideAnnot = factory.createAnnotation(factory.createCtTypeReference(Override.class));
		testClass.getMethods().forEach(m -> m.addAnnotation(overrideAnnot));

		addAttributes();

		addTearDown();
	}

	/**
	 * Finds a generics declaration in its super classes
	 */
	private static CtTypeParameter findGenerics(final CtTypeReference<?> type, final String genericName) {
		if(type == null) {
			return null;
		}
		return type
			.getTypeDeclaration()
			.getFormalCtTypeParameters()
			.stream()
			.filter(g -> genericName.equals(g.getSimpleName()))
			.findFirst()
			.orElseGet(() -> findGenerics(type.getSuperclass(), genericName));
	}

	private void addAttributes() {
		fields = cmd.getAllFields()
			.stream()
			.filter(f -> !f.getDeclaringType().equals(cmdTypeRef))
			.map(f -> {
				CtTypeReference<?> newType = f.getType();
				// If the type is a generics, have to replace it by its concrete definition
				if(newType instanceof CtTypeParameterReference) {
					final CtTypeParameter param = findGenerics(f.getDeclaringType(), f.getType().getSimpleName());
					if(param.getSuperclass() == null) {
						// If no super bound, use Object
						newType = factory.createCtTypeReference(Object.class);
					}else {
						newType = param.getSuperclass();
					}
				}
				// Removing all the annotations put on the field
				final var newTypeConst = newType;
				List.copyOf(f.getAnnotations()).forEach(a -> f.removeAnnotation(a));
				List.copyOf(newType.getAnnotations()).forEach(a -> newTypeConst.removeAnnotation(a));

				return (CtField<?>) factory.createField(testClass, Set.of(), newType, f.getSimpleName());
			})
			.collect(Collectors.toList());
	}

	private void addSuperTestClass() {
		final CtTypeReference<?> ref;

		if(isUndoable) {
			ref = factory.createCtTypeReference(UndoableCmdTest.class);
		}else {
			ref = factory.createCtTypeReference(CommandTest.class);
		}

		ref.addActualTypeArgument(cmd.getReference());
		testClass.setSuperclass(ref);
	}

	private void addTearDown() {
		final CtMethod<?> tearDown = factory.createMethod(testClass,
			Set.of(),
			factory.Type().voidPrimitiveType(),
			"tearDown" + testClass.getSimpleName(),
			List.of(), Set.of());
		final CtBlock<?> body = factory.createBlock();

		tearDown.addAnnotation(factory.createAnnotation(factory.createCtTypeReference(AfterEach.class)));
		tearDown.setBody(body);

		body.getStatements().addAll(
			fields.stream()
				.map(f -> factory.createVariableAssignment(f.getReference(), false, factory.createLiteral(null)))
				.collect(Collectors.toList())
		);

	}
}
