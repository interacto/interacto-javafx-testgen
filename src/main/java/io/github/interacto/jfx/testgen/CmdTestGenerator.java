/*
 * Interacto
 * Copyright (C) 2020 Arnaud Blouin
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package io.github.interacto.jfx.testgen;

import io.github.interacto.command.CommandImpl;
import io.github.interacto.jfx.test.CommandTest;
import io.github.interacto.jfx.test.UndoableCmdTest;
import io.github.interacto.undo.Undoable;
import java.lang.annotation.Annotation;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Tag;
import spoon.reflect.code.CtBlock;
import spoon.reflect.code.CtComment;
import spoon.reflect.code.CtLiteral;
import spoon.reflect.declaration.CtAnnotation;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.declaration.CtField;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.declaration.CtType;
import spoon.reflect.declaration.CtTypeParameter;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtTypeParameterReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.template.Substitution;

public class CmdTestGenerator {
	private final CtClass<?> cmd;

	private CtTypeReference<?> cmdTypeRef;
	private Factory factory;
	private CtClass<?> testClass;
	boolean isUndoable;
	private List<CtField<?>> fields;

	public CmdTestGenerator(final CtClass<?> cmd) {
		super();
		this.cmd = cmd;
	}


	public void generate() {
		factory = cmd.getFactory();
		cmdTypeRef = factory.createCtTypeReference(CommandImpl.class);
		testClass = factory.createClass(cmd.getPackage(), cmd.getSimpleName() + "Test");
		isUndoable = cmd.isSubtypeOf(factory.createCtTypeReference(Undoable.class));

		final var annotTag = factory.createAnnotation(factory.createCtTypeReference(Tag.class));
		annotTag.addValue("value", "command");
		testClass.addAnnotation(annotTag);

		testClass.addComment(factory.createComment("Test class for the command " + cmd.getSimpleName() +
				". Generated by Interacto test-gen.", CtComment.CommentType.JAVADOC));

		addSuperTestClass();

		Substitution.insertAllMethods(testClass, new CmdTestClassTemplate());
		final CtAnnotation<Annotation> overrideAnnot = factory.createAnnotation(factory.createCtTypeReference(Override.class));
		testClass.getMethods().forEach(m -> m.addAnnotation(overrideAnnot));

		// If undoable, the method undoChecker must be implemented
		if(isUndoable) {
			final var undochecker = testClass.getMethod("doChecker").clone();
			undochecker.setSimpleName("undoChecker");
			testClass.addMethod(undochecker);
		}

		// If the method canDo is implemented in the command or in a parent
		// the method cannotDoConfigurations must be generated.
		if(hasCanDo()) {
			final var undochecker = testClass.getMethod("canDoConfigurations").clone();
			undochecker.setSimpleName("cannotDoConfigurations");
			testClass.addMethod(undochecker);
		}

		addAttributes();

		addTearDown();
	}

	private boolean hasCanDo() {
		boolean cando = false;
		CtType<?> currentType = cmd;

		while(!cando && !"CommandImpl".equals(currentType.getSimpleName())) {
			cando = currentType
				.getMethods()
				.stream()
				.anyMatch(m -> m.getParameters().isEmpty() && "canDo".equals(m.getSimpleName()));
			currentType = currentType.getSuperclass().getTypeDeclaration();
		}

		return cando;
	}

	/**
	 * Finds a generics declaration in its super classes
	 */
	private static CtTypeReference<?> findGenerics(final CtTypeReference<?> type, final String genericName, final List<CtTypeReference<?>> typeArgs) {
		if(type == null) {
			return null;
		}
		final List<CtTypeParameter> formalParams = type.getTypeDeclaration().getFormalCtTypeParameters();

		return formalParams
			.stream()
			.filter(g -> genericName.equals(g.getSimpleName()))
			.findFirst()
			.map(g -> {
				// The type has a generics that matches the name we are looking for.
				// So, we look whether the lower class specified type arguments related to this class
				// If yes, we return this type argument as it is a specialisation of the generics.
				// If no, we take the generics and grabs its super bound (class). Interfaces should be supported in a future version
				final var i = formalParams.indexOf(g);
				if(i >= typeArgs.size()) {
					// If no super bound, use Object
					if(g.getSuperclass() == null) {
						return type.getFactory().createCtTypeReference(Object.class);
					}
					return g.getSuperclass();
				}
				return typeArgs.get(i);
			})
			.orElseGet(() -> findGenerics(type.getSuperclass(), genericName,
				type.getSuperclass() == null ? List.of() : type.getSuperclass().getActualTypeArguments()));
	}

	private void addAttributes() {
		fields = cmd.getAllFields()
			.stream()
			.filter(f -> !f.getDeclaringType().equals(cmdTypeRef))
			.map(f -> {
				// If the type is a generics, have to replace it by its concrete definition
				final CtTypeReference<?> newType = f.getType() instanceof CtTypeParameterReference ?
					findGenerics(cmd.getReference(), f.getType().getSimpleName(), List.of()) : f.getType();
				// Removing all the annotations put on the field
				List.copyOf(f.getAnnotations()).forEach(a -> f.removeAnnotation(a));
				List.copyOf(newType.getAnnotations()).forEach(a -> newType.removeAnnotation(a));

				return (CtField<?>) factory.createField(testClass, Set.of(), newType, f.getSimpleName());
			})
			.collect(Collectors.toList());
	}

	private void addSuperTestClass() {
		final CtTypeReference<?> ref;

		if(isUndoable) {
			ref = factory.createCtTypeReference(UndoableCmdTest.class);
		}else {
			ref = factory.createCtTypeReference(CommandTest.class);
		}

		ref.addActualTypeArgument(cmd.getReference());
		testClass.setSuperclass(ref);
	}

	private void addTearDown() {
		final CtMethod<?> tearDown = factory.createMethod(testClass,
			Set.of(),
			factory.Type().voidPrimitiveType(),
			"tearDown" + testClass.getSimpleName(),
			List.of(), Set.of());
		final CtBlock<?> body = factory.createBlock();

		tearDown.addAnnotation(factory.createAnnotation(factory.createCtTypeReference(AfterEach.class)));
		tearDown.setBody(body);

		body.getStatements().addAll(
			fields.stream()
				.map(f -> factory.createVariableAssignment(f.getReference(), false,
					(CtLiteral) factory.createLiteral(getDefaultLiteral(f.getType()))))
				.collect(Collectors.toList())
		);
	}

	private static Object getDefaultLiteral(final CtTypeReference<?> type) {
		if(type.isPrimitive()) {
			if(type.equals(type.getFactory().Type().BOOLEAN_PRIMITIVE)) {
				return false;
			}
			return 0;
		}
		return null;
	}
}
